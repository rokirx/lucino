%include {
#include "lucene.h"
#include "lcn_search.h"


/* autogenerated funktions, do not touch */
void
lcn_query_parser_(void*, int, lcn_query_token_t *, lcn_query_info_t* info );

void *
lcn_query_parser_Alloc(void *(*malloc_proc)(size_t));

void
lcn_query_parser_Trace( FILE *stream, char *z);

void lcn_query_parser_Free(
    void *p,                    /* The parser to be deleted        */
    void (*free_proc)(void*)    /* Function used to reclaim memory */
);

/* end of autogenerated functions */


void
lcn_query_parser_parse( void* p,
                        int token_id,
                        lcn_query_token_t *t,
                        lcn_query_info_t* info )
{
    lcn_query_parser_( p, token_id, t, info );
}


void *
lcn_query_parser_alloc(void *(*malloc_proc)(size_t))
{
    return lcn_query_parser_Alloc( malloc_proc );
}

void
lcn_query_parser_trace( FILE *stream, char *z)
{
#ifndef NDEBUG
    lcn_query_parser_Trace( stream, z);
#endif
}

void lcn_query_parser_free( void *p, void (*free_proc)(void*))
{
    lcn_query_parser_Free( p, free_proc );
}

struct lcn_query_with_clause_t
{
    lcn_query_t *query;
    int clause;
};

static lcn_query_t*
query_list_to_query( lcn_list_t* query_list, apr_pool_t *pool )
{
    unsigned int i;
    lcn_query_t *bq;

    (void) lcn_boolean_query_create( &bq, pool );

    for( i = 0; i < lcn_list_size( query_list ); i++ )
    {
        struct lcn_query_with_clause_t* t = lcn_list_get( query_list, i );
        (void) lcn_boolean_query_add( bq, t->query, t->clause );
    }

    return bq;
}

}

%parse_failure {
    info->status = LCN_ERR_QUERY_PARSER_SYNTAX_ERROR;
}

%name lcn_query_parser_
%token_prefix LCNQ_
%token_type {lcn_query_token_t *}
%extra_argument { lcn_query_info_t* info }

%left SPACE.
%nonassoc CLAUSE.

%type expr         { lcn_query_t * }
%type bool_query   { lcn_query_t * }
%type query_list   { lcn_list_t  * }
%type term_list    { lcn_list_t  * }
%type term         { char        * }
%type term_query   { lcn_query_t * }
%type prefix_query { lcn_query_t * }
%type phrase_query { lcn_query_t * }
%type some_query   { lcn_query_t * }

query ::= expr(X) . {
    info->query = X;
}

term_list(X) ::= term_list(A) SPACE TERM_TEXT(B)  . {
    (void) lcn_list_add( A, apr_pstrdup( info->pool, B->text) );
    X = A;
}

term_list(X) ::= TERM_TEXT(A) . {
    (void) lcn_list_create( &(X), 10, info->pool );
    (void) lcn_list_add( X, apr_pstrdup( info->pool, A->text ) );
}

phrase_query(X) ::= FIELD_PREFIX(P) SEP QUOT_MARK term_list(A) QUOT_MARK . {
    lcn_list_t *term_list;
    unsigned int i;

    (void) lcn_multi_phrase_query_create( &(X), info->pool );
    (void) lcn_list_create( &term_list, 10, info->pool );

    for( i = 0; i < lcn_list_size( A ); i++ )
    {
        lcn_term_t *term;
        lcn_term_create( &term,
                         P->text,
                         (char*) lcn_list_get( A, i ),
                         LCN_TERM_TEXT_COPY,
                         info->pool );
        (void) lcn_multi_phrase_query_add_term( X, term );
    }
}

prefix_query(X) ::= FIELD_PREFIX(A) SEP ASTERISK . {
    lcn_term_t *term;

    (void) lcn_term_create( &term, A->text, "", LCN_TERM_TEXT_COPY, info->pool );
    (void) lcn_prefix_query_create( &(X), term, info->pool );
}

prefix_query(X) ::= FIELD_PREFIX(A) SEP TERM_TEXT(B) ASTERISK . {
    lcn_term_t *term;

    (void) lcn_term_create( &term, A->text, B->text, LCN_TERM_TEXT_COPY, info->pool );
    (void) lcn_prefix_query_create( &(X), term, info->pool );
}

term_query(X) ::= FIELD_PREFIX(A) SEP TERM_TEXT(B) . {
    (void) lcn_term_query_create_by_chars( &(X), A->text, B->text, info->pool );
}

bool_query(X) ::= OPEN_BR query_list(A) CLOSE_BR . {
    lcn_query_t *q = query_list_to_query( A, info->pool );
    X = q;
}

some_query(X) ::= bool_query(A) .   { X = A; }
some_query(X) ::= phrase_query(A) . { X = A; }
some_query(X) ::= prefix_query(A) . { X = A; }
some_query(X) ::= term_query(A) .   { X = A; }


query_list(X) ::= CLAUSE(C) some_query(B) . {
    struct lcn_query_with_clause_t* q = apr_pcalloc( info->pool, sizeof(struct lcn_query_with_clause_t));
    (void) lcn_list_create( &(X), 10, info->pool );
    q->query = B;
    q->clause = (*(C->text) == '-' ? LCN_BOOLEAN_CLAUSE_MUST_NOT : LCN_BOOLEAN_CLAUSE_MUST);
    (void) lcn_list_add( X, q );
}

query_list(X) ::= some_query(B) . {
    struct lcn_query_with_clause_t* q = apr_pcalloc( info->pool, sizeof(struct lcn_query_with_clause_t));
    (void) lcn_list_create( &(X), 10, info->pool );
    q->query = B;
    q->clause = LCN_BOOLEAN_CLAUSE_SHOULD;
    (void) lcn_list_add( X, q );
}

query_list(X) ::= query_list(A) SPACE CLAUSE(C) some_query(B) . {
    struct lcn_query_with_clause_t* q = apr_pcalloc( info->pool, sizeof(struct lcn_query_with_clause_t));
    q->query = B;
    q->clause = (*(C->text) == '-' ? LCN_BOOLEAN_CLAUSE_MUST_NOT : LCN_BOOLEAN_CLAUSE_MUST);
    (void) lcn_list_add( A, q );
    X = A;
}

query_list(X) ::= query_list(A) SPACE some_query(B) . {
    struct lcn_query_with_clause_t* q = apr_pcalloc( info->pool, sizeof(struct lcn_query_with_clause_t));
    q->query = B;
    q->clause = LCN_BOOLEAN_CLAUSE_SHOULD;
    (void) lcn_list_add( A, q );
    X = A;
}

expr(X) ::= query_list(A) . {
    X = query_list_to_query( A, info->pool );
}
